import * as NeuQuant from "./NeuQuant.js";
import * as LZWEncoder from "./LZWEncoder.js";
class ByteArray {
    bin = [];
    constructor() {
        this.bin = [];
    }
    getChrCode(i) {
        return String.fromCharCode(i);
    }
    getData() {
        let v = "";
        for (let l = this.bin.length, i = 0; i < l; i++)
            v += this.getChrCode(this.bin[i]);
        return v;
    }
    writeByte(val) {
        this.bin.push(val);
    }
    writeBytes(array, offset, length) {
        for (let l = length || array.length, i = offset || 0; i < l; i++) {
            this.writeByte(array[i]);
        }
    }
    writeUTFBytes(str) {
        for (let len = str.length, i = 0; i < len; i++) {
            this.bin.push(str.charCodeAt(i));
        }
    }
}
class GIFEncoder {
    width;
    height;
    transparent;
    repeat;
    delay;
    sample;
    closeStream;
    out;
    gifBuffer;
    started;
    image;
    sizeSet;
    firstFrame;
    pixels;
    usedEntry;
    indexedPixels;
    colorTab;
    colorDepth;
    palSize;
    transIndex;
    dispose;
    comment;
    constructor() {
        this.width = undefined;
        this.height = undefined;
        this.transparent = null;
        this.repeat = -1;
        this.delay = 0;
        this.closeStream = false;
        this.sample = 10;
        this.out = [];
        this.gifBuffer = new ByteArray();
        this.started = false;
        this.image = null;
        this.sizeSet = false;
        this.firstFrame = true;
        this.pixels = [];
        this.usedEntry = [];
        this.indexedPixels = null;
        this.colorTab = null;
        this.colorDepth = 0;
        this.palSize = null;
        this.transIndex = 0;
        this.dispose = -1;
        this.comment =
            "Generated by jsgif (https://github.com/antimatter15/jsgif/)";
    }
    setSize(w, h) {
        if (this.started && !this.firstFrame)
            return;
        this.width = w;
        this.height = h;
        if (this.width < 1)
            this.width = 320;
        if (this.height < 1)
            this.height = 240;
        this.sizeSet = true;
    }
    setFrameRate(fps) {
        if (fps !== 0xf) {
            this.delay = Math.round(100 / fps);
        }
    }
    setQuality(quality) {
        if (quality < 1)
            quality = 1;
        this.sample = quality;
    }
    setDelay(ms) {
        this.delay = Math.round(ms / 10);
    }
    setRepeat(iter) {
        if (iter >= 0) {
            this.repeat = iter;
        }
    }
    start() {
        this.reset();
        let ok = true;
        this.closeStream = false;
        this.gifBuffer = new ByteArray();
        this.out = this.gifBuffer.bin;
        try {
            this.gifBuffer.writeUTFBytes("GIF89a");
        }
        catch (e) {
            ok = false;
        }
        return (this.started = ok);
    }
    finish() {
        if (!this.started)
            return false;
        let ok = true;
        this.started = false;
        try {
            this.gifBuffer.writeByte(0x3b);
            this.closeStream = true;
        }
        catch (e) {
            ok = false;
        }
        return ok;
    }
    addFrame(im, is_imageData) {
        if (im === null || !this.started || this.out === null) {
            throw new Error("Please call start method before calling addFrame");
        }
        let ok = true;
        try {
            if (!is_imageData) {
                this.image = im.getImageData(0, 0, im.canvas.width, im.canvas.height).data;
                if (!this.sizeSet)
                    this.setSize(im.canvas.width, im.canvas.height);
            }
            else {
                if (im instanceof ImageData) {
                    this.image = im.data;
                    if (!this.sizeSet ||
                        this.width !== im.width ||
                        this.height !== im.canvas.height) {
                        this.setSize(im.width, im.height);
                    }
                }
                else if (im instanceof Uint8ClampedArray) {
                    if (im.length === (this.width || 0) * (this.height || 0) * 4) {
                        this.image = im;
                    }
                    else {
                        console.log("Please set the correct size: ImageData length mismatch");
                        ok = false;
                    }
                }
                else {
                    console.log("Please provide correct input");
                    ok = false;
                }
            }
            this.getImagePixels();
            this.analyzePixels();
            if (this.firstFrame) {
                this.writeLSD();
                this.writePalette();
                if (this.repeat >= 0) {
                    this.writeNetscapeExt();
                }
            }
            this.writeGraphicCtrlExt();
            if (this.comment !== "") {
                this.writeCommentExt();
            }
            this.writeImageDesc();
            if (!this.firstFrame)
                this.writePalette();
            this.writePixels();
            this.firstFrame = false;
        }
        catch (e) {
            ok = false;
        }
        return ok;
    }
    writePixels() {
        let myencoder = new LZWEncoder(this.width, this.height, this.indexedPixels, this.colorDepth);
        myencoder.encode(this.gifBuffer);
    }
    writeImageDesc() {
        if (this.width === undefined || this.height === undefined) {
            console.log("Width and Height are not setup correctly in the encoder");
            return;
        }
        if (this.palSize === null) {
            console.log("Pallet size is not correctly setup in encoder");
            return;
        }
        this.gifBuffer.writeByte(0x2c);
        this.WriteShort(0);
        this.WriteShort(0);
        this.WriteShort(this.width);
        this.WriteShort(this.height);
        if (this.firstFrame) {
            this.gifBuffer.writeByte(0);
        }
        this.gifBuffer.writeByte(0x80 |
            0 |
            0 |
            0 |
            this.palSize);
    }
    writeCommentExt() {
        this.gifBuffer.writeByte(0x21);
        this.gifBuffer.writeByte(0xfe);
        this.gifBuffer.writeByte(this.comment.length);
        this.gifBuffer.writeUTFBytes(this.comment);
        this.gifBuffer.writeByte(0);
    }
    writeGraphicCtrlExt() {
        this.gifBuffer.writeByte(0x21);
        this.gifBuffer.writeByte(0xf9);
        this.gifBuffer.writeByte(4);
        let transp;
        let disp;
        if (this.transparent === null) {
            transp = 0;
            disp = 0;
        }
        else {
            transp = 1;
            disp = 2;
        }
        if (this.dispose >= 0) {
            disp = this.dispose & 7;
        }
        disp <<= 2;
        this.gifBuffer.writeByte(0 |
            disp |
            0 |
            transp);
        this.WriteShort(this.delay);
        this.gifBuffer.writeByte(this.transIndex);
        this.gifBuffer.writeByte(0);
    }
    writeNetscapeExt() {
        this.gifBuffer.writeByte(0x21);
        this.gifBuffer.writeByte(0xff);
        this.gifBuffer.writeByte(11);
        this.gifBuffer.writeUTFBytes("NETSCAPE" + "2.0");
        this.gifBuffer.writeByte(3);
        this.gifBuffer.writeByte(1);
        this.WriteShort(this.repeat);
        this.gifBuffer.writeByte(0);
    }
    WriteShort(pValue) {
        this.gifBuffer.writeByte(pValue & 0xff);
        this.gifBuffer.writeByte((pValue >> 8) & 0xff);
    }
    writePalette() {
        if (this.colorTab === null) {
            console.log("Color Table is not correctly setup in the encoder");
            return;
        }
        this.gifBuffer.writeBytes(this.colorTab);
        let n = 3 * 256 - this.colorTab.length;
        for (let i = 0; i < n; i++)
            this.gifBuffer.writeByte(0);
    }
    writeLSD() {
        if (this.width === undefined || this.height === undefined) {
            console.log("Width or Height Or both are not setup correctly in the encoder");
            return;
        }
        if (this.palSize === null) {
            console.log("pallet size was not setup correctly in the encoder");
            return;
        }
        this.WriteShort(this.width);
        this.WriteShort(this.height);
        this.gifBuffer.writeByte(0x80 |
            0x70 |
            0x00 |
            this.palSize);
        this.gifBuffer.writeByte(0);
        this.gifBuffer.writeByte(0);
    }
    analyzePixels() {
        if (!this.pixels) {
            console.log("Pixels were not correctly setup in encoder");
            return;
        }
        let len = this.pixels.length;
        let nPix = len / 3;
        this.indexedPixels = [];
        let nq = new NeuQuant(this.pixels, len, this.sample);
        this.colorTab = nq.process();
        let k = 0;
        for (let j = 0; j < nPix; j++) {
            var index = nq.map(this.pixels[k++] & 0xff, this.pixels[k++] & 0xff, this.pixels[k++] & 0xff);
            this.usedEntry[index] = true;
            this.indexedPixels[j] = index;
        }
        this.pixels = null;
        this.colorDepth = 8;
        this.palSize = 7;
        if (this.transparent !== null) {
            this.transIndex = this.findClosest(this.transparent);
        }
    }
    findClosest(c) {
        if (this.colorTab === null)
            return -1;
        let r = (c & 0xff0000) >> 16;
        let g = (c & 0x00ff00) >> 8;
        let b = c & 0x0000ff;
        let minpos = 0;
        let dmin = 256 * 256 * 256;
        let len = this.colorTab.length;
        for (let i = 0; i < len;) {
            let dr = r - (this.colorTab[i++] & 0xff);
            let dg = g - (this.colorTab[i++] & 0xff);
            let db = b - (this.colorTab[i++] & 0xff);
            let d = dr * dr + dg * dg + db * db;
            let index = i / 3;
            if (this.usedEntry[index] && d < dmin) {
                dmin = d;
                minpos = index;
            }
            i++;
        }
        return minpos;
    }
    getImagePixels() {
        let w = this.width;
        let h = this.height;
        this.pixels = [];
        let data = this.image;
        let count = 0;
        if (w === undefined || h === undefined) {
            console.error("Width and Height of the image is not correct");
            return;
        }
        if (data === null) {
            console.log("Image provided was null");
            return;
        }
        for (let i = 0; i < h; i++) {
            for (let j = 0; j < w; j++) {
                let b = i * w * 4 + j * 4;
                this.pixels[count++] = data[b];
                this.pixels[count++] = data[b + 1];
                this.pixels[count++] = data[b + 2];
            }
        }
    }
    stream() {
        return this.out;
    }
    cont() {
        this.reset();
        let ok = true;
        this.closeStream = false;
        this.gifBuffer = new ByteArray();
        this.out = this.gifBuffer.bin;
        return (this.started = ok);
    }
    reset() {
        this.transIndex = 0;
        this.image = null;
        this.pixels = null;
        this.indexedPixels = null;
        this.colorTab = null;
        this.closeStream = false;
        this.firstFrame = true;
    }
}
const gifBuffer = new ByteArray();
gifBuffer.writeUTFBytes("GIF89a");
console.log(gifBuffer);
