import {NeuQuant} from "./NeuQuant.js";
import {LZWEncoder} from "./LZWEncoder.js";

export class ByteArray {
  bin: number[] = [];
  constructor() {
    this.bin = [];
  }

  getChrCode(i: number) {
    return String.fromCharCode(i);
  }

  getData() {
    let v = "";
    for (let l = this.bin.length, i = 0; i < l; i++)
      v += this.getChrCode(this.bin[i]);
    return v;
  }

  writeByte(val: number) {
    this.bin.push(val);
  }

  writeBytes(array: number[], offset?: number, length?: number) {
    for (let l = length || array.length, i = offset || 0; i < l; i++) {
      this.writeByte(array[i]);
    }
  }

  writeUTFBytes(str: string) {
    for (let len = str.length, i = 0; i < len; i++) {
      this.bin.push(str.charCodeAt(i));
    }
  }
}

export class GIFEncoder {
  width: number | undefined;
  height: number | undefined;
  transparent: never | null;
  repeat: number;
  delay: number;
  sample: number;
  closeStream: boolean;
  out: number[];
  gifBuffer: ByteArray;
  started: boolean;
  image:
    | (CanvasRenderingContext2D & Uint8ClampedArray<ArrayBufferLike>)
    | ImageDataArray
    | null;
  sizeSet: boolean;
  firstFrame: boolean;
  pixels: number[] | null;
  usedEntry: boolean[];
  indexedPixels: number[] | null;
  colorTab: number[] | null;
  colorDepth: number;
  palSize: number | null;
  transIndex: number;
  dispose: number;
  comment: string;

  constructor() {
    this.width = undefined;
    this.height = undefined;
    this.transparent = null;
    this.repeat = -1;
    this.delay = 0;
    this.closeStream = false;
    this.sample = 10;
    this.out = [];
    this.gifBuffer = new ByteArray();
    this.started = false;
    this.image = null;
    this.sizeSet = false;
    this.firstFrame = true;
    this.pixels = [];
    this.usedEntry = [];
    this.indexedPixels = null;
    this.colorTab = null;
    this.colorDepth = 0;
    this.palSize = null;
    this.transIndex = 0;
    this.dispose = -1;
    this.comment =
      "Generated by jsgif (https://github.com/antimatter15/jsgif/)";
  }

  setSize(w: number, h: number) {
    if (this.started && !this.firstFrame) return;

    this.width = w;
    this.height = h;

    if (this.width < 1) this.width = 320;
    if (this.height < 1) this.height = 240;
    this.sizeSet = true;
  }

  setFrameRate(fps: number) {
    if (fps !== 0xf) {
      this.delay = Math.round(100 / fps);
    }
  }

  setQuality(quality: number) {
    if (quality < 1) quality = 1;
    this.sample = quality;
  }

  setDelay(ms: number) {
    this.delay = Math.round(ms / 10);
  }

  setRepeat(iter: number) {
    if (iter >= 0) {
      this.repeat = iter;
    }
  }

  start() {
    this.reset();
    let ok = true;

    this.closeStream = false;
    this.gifBuffer = new ByteArray();
    this.out = this.gifBuffer.bin;
    try {
      this.gifBuffer.writeUTFBytes("GIF89a");
    } catch (e: any) {
      ok = false;
    }

		console.log(this.out);
    return (this.started = ok);
  }

  finish() {
    if (!this.started) return false;

    let ok = true;
    this.started = false;

    try {
      this.gifBuffer.writeByte(0x3b); // gif trailer
      this.closeStream = true;
    } catch (e: any) {
      ok = false;
    }

    return ok;
  }

  addFrame(im: CanvasRenderingContext2D, is_imageData?: boolean) {
    if (im === null || !this.started || this.out === null) {
      throw new Error("Please call start method before calling addFrame");
    }

    let ok = true;

    try {
      if (!is_imageData) {
        this.image = im.getImageData(
          0,
          0,
          im.canvas.width,
          im.canvas.height,
        ).data;
        if (!this.sizeSet) this.setSize(im.canvas.width, im.canvas.height);
      } else {
        if (im instanceof ImageData) {
          this.image = im.data;
          if (
            !this.sizeSet ||
            this.width !== im.width ||
            this.height !== im.canvas.height
          ) {
            this.setSize(im.width, im.height);
          }
        } else if (im instanceof Uint8ClampedArray) {
          if (im.length === (this.width || 0) * (this.height || 0) * 4) {
            this.image = im;
          } else {
            console.log(
              "Please set the correct size: ImageData length mismatch",
            );
            ok = false;
          }
        } else {
          console.log("Please provide correct input");
          ok = false;
        }
      }

      this.getImagePixels();
      this.analyzePixels();

      if (this.firstFrame) {
        this.writeLSD(); // logical screen descriptor
        this.writePalette(); // global color table
        if (this.repeat >= 0) {
          this.writeNetscapeExt();
        }
      }

      this.writeGraphicCtrlExt();
      if (this.comment !== "") {
        this.writeCommentExt();
      }
      this.writeImageDesc(); // image descriptor

      if (!this.firstFrame) this.writePalette();
      this.writePixels(); // encode and write pixel data
      this.firstFrame = false;
    } catch (e) {
      ok = false;
    }

    return ok;
  }

  writePixels() {
    let myencoder = new LZWEncoder(
      this.width || 0,
      this.height || 0,
      this.indexedPixels || [],
      this.colorDepth || 0,
    );
    myencoder.encode(this.gifBuffer);
  }

  writeImageDesc() {
    if (this.width === undefined || this.height === undefined) {
      console.log("Width and Height are not setup correctly in the encoder");
      return;
    }
    if (this.palSize === null) {
      console.log("Pallet size is not correctly setup in encoder");
      return;
    }
    this.gifBuffer.writeByte(0x2c); // Image seperator
    this.WriteShort(0); // image position x, y = 0, 0
    this.WriteShort(0);

    this.WriteShort(this.width); // image size
    this.WriteShort(this.height);

    if (this.firstFrame) {
      this.gifBuffer.writeByte(0);
    }

    this.gifBuffer.writeByte(
      0x80 | // 1 local color table 1=yes
        0 | // 2 interlace - 0=no
        0 | // 3 sorted -0=no
        0 | // 4-5 reserved
        this.palSize,
    ); // 6-8 size of color table
  }

  writeCommentExt() {
    this.gifBuffer.writeByte(0x21); // extension introducer
    this.gifBuffer.writeByte(0xfe); // comment label
    this.gifBuffer.writeByte(this.comment.length); // Block Size (s)
    this.gifBuffer.writeUTFBytes(this.comment);
    this.gifBuffer.writeByte(0);
  }

  writeGraphicCtrlExt() {
    this.gifBuffer.writeByte(0x21); // extension introducer
    this.gifBuffer.writeByte(0xf9); // GCE lable
    this.gifBuffer.writeByte(4); // data block size

    let transp;
    let disp;
    if (this.transparent === null) {
      transp = 0;
      disp = 0; // dispose = no action
    } else {
      transp = 1;
      disp = 2; // force clear if using transparent color
    }

    if (this.dispose >= 0) {
      disp = this.dispose & 7; // user override
    }

    disp <<= 2;
    // packed fields
    this.gifBuffer.writeByte(
      0 | // 1:3 reserved
        disp | // 4:6 disposal
        0 | // 7 user input - 0 = none
        transp,
    );

    this.WriteShort(this.delay); // delay x 1/100 sec
    this.gifBuffer.writeByte(this.transIndex); // transparent color index
    this.gifBuffer.writeByte(0);
  }

  writeNetscapeExt() {
    this.gifBuffer.writeByte(0x21); // extension introducer
    this.gifBuffer.writeByte(0xff); // app extension label
    this.gifBuffer.writeByte(11); // block size
    this.gifBuffer.writeUTFBytes("NETSCAPE" + "2.0"); // app id + auth code
    this.gifBuffer.writeByte(3); // sub-block size
    this.gifBuffer.writeByte(1); // loop sub-block id
    this.WriteShort(this.repeat); // loop count (extra iterations, 0=repeat forever)
    this.gifBuffer.writeByte(0); // block terminatior
  }

  WriteShort(pValue: number) {
    this.gifBuffer.writeByte(pValue & 0xff);
    this.gifBuffer.writeByte((pValue >> 8) & 0xff);
  }

  writePalette() {
    if (this.colorTab === null) {
      console.log("Color Table is not correctly setup in the encoder");
      return;
    }
    this.gifBuffer.writeBytes(this.colorTab);
    let n = 3 * 256 - this.colorTab.length;
    for (let i = 0; i < n; i++) this.gifBuffer.writeByte(0);
  }

  writeLSD() {
    if (this.width === undefined || this.height === undefined) {
      console.log(
        "Width or Height Or both are not setup correctly in the encoder",
      );
      return;
    }
    if (this.palSize === null) {
      console.log("pallet size was not setup correctly in the encoder");
      return;
    }
    this.WriteShort(this.width);
    this.WriteShort(this.height);

    this.gifBuffer.writeByte(
      0x80 | // 1 : global color table flag = 1 (gct used)
        0x70 | // 2-4 : color resolution = 7
        0x00 | // 5 : gct sort flag = 0
        this.palSize,
    );

    this.gifBuffer.writeByte(0); // backgfound color index
    this.gifBuffer.writeByte(0); // pixel aspect ratio - assume 1:1
  }

  analyzePixels() {
    if (!this.pixels) {
      console.log("Pixels were not correctly setup in encoder");
      return;
    }
    let len = this.pixels.length;
    let nPix = len / 3;
    this.indexedPixels = [];

    let nq = new NeuQuant(this.pixels, len, this.sample);
    this.colorTab = nq.process() as number[]; // create reduced palette
    let k = 0;
    for (let j = 0; j < nPix; j++) {
      var index = nq.map(
        this.pixels[k++] & 0xff,
        this.pixels[k++] & 0xff,
        this.pixels[k++] & 0xff,
      );
      this.usedEntry[index] = true;
      this.indexedPixels[j] = index;
    }

    this.pixels = null;
    this.colorDepth = 8;
    this.palSize = 7;

    if (this.transparent !== null) {
      this.transIndex = this.findClosest(this.transparent);
    }
  }

  findClosest(c: number) {
    if (this.colorTab === null) return -1;
    let r = (c & 0xff0000) >> 16;
    let g = (c & 0x00ff00) >> 8;
    let b = c & 0x0000ff;
    let minpos = 0;
    let dmin = 256 * 256 * 256;
    let len = this.colorTab.length;

    for (let i = 0; i < len; ) {
      let dr = r - (this.colorTab[i++] & 0xff);
      let dg = g - (this.colorTab[i++] & 0xff);
      let db = b - (this.colorTab[i++] & 0xff);
      let d = dr * dr + dg * dg + db * db;
      let index = i / 3;
      if (this.usedEntry[index] && d < dmin) {
        dmin = d;
        minpos = index;
      }
      i++;
    }
    return minpos;
  }

  getImagePixels() {
    let w = this.width;
    let h = this.height;
    this.pixels = [];

    let data = this.image;
    let count = 0;

    if (w === undefined || h === undefined) {
      console.error("Width and Height of the image is not correct");
      return;
    }
    if (data === null) {
      console.log("Image provided was null");
      return;
    }
    for (let i = 0; i < h; i++) {
      for (let j = 0; j < w; j++) {
        let b = i * w * 4 + j * 4;
        this.pixels[count++] = data[b];
        this.pixels[count++] = data[b + 1];
        this.pixels[count++] = data[b + 2];
      }
    }
  }

  stream() {
    return this.out;
  }

  cont() {
    this.reset();
    let ok = true;
    this.closeStream = false;
    this.gifBuffer = new ByteArray();
    this.out = this.gifBuffer.bin;

    return (this.started = ok);
  }

  reset() {
    this.transIndex = 0;
    this.image = null;
    this.pixels = null;
    this.indexedPixels = null;
    this.colorTab = null;
    this.closeStream = false;
    this.firstFrame = true;
  }
}
